import {
  Registry,
  RegistrySchema,
  createRegistry,
  updateRegistryStats
} from '../logic/being/schema/registry';

/**
 * RegistryService
 *
 * A service for managing registries in the system.
 * Registries serve as containers for entities, relations, and contexts,
 * providing organization and structure to the frameworks generated by the Organon.
 */
export class RegistryService {
  private static instance: RegistryService;

  // In-memory registry storage
  private registries: Map<string, Registry> = new Map();

  // Type-based index
  private typeIndex: Map<string, Set<string>> = new Map();

  // Private constructor for singleton
  private constructor() {}

  /**
   * Get the singleton instance
   */
  public static getInstance(): RegistryService {
    if (!RegistryService.instance) {
      RegistryService.instance = new RegistryService();
    }
    return RegistryService.instance;
  }

  /**
   * Add registry to indices
   */
  private addToIndices(registry: Registry): void {
    // Add to type index
    if (!this.typeIndex.has(registry.type)) {
      this.typeIndex.set(registry.type, new Set());
    }
    this.typeIndex.get(registry.type)!.add(registry.id);
  }

  /**
   * Remove registry from indices
   */
  private removeFromIndices(registry: Registry): void {
    // Remove from type index
    this.typeIndex.get(registry.type)?.delete(registry.id);
    if (this.typeIndex.get(registry.type)?.size === 0) {
      this.typeIndex.delete(registry.type);
    }
  }

  /**
   * Create a new registry
   */
  createRegistry(params: {
    name: string;
    description?: string;
    type?: Registry['type'];
    properties?: Record<string, any>;
    active?: boolean;
  }): Registry {
    // Create the registry
    const registry = createRegistry(params);

    // Validate with schema
    const validatedRegistry = RegistrySchema.parse(registry);

    // Store the registry
    this.registries.set(registry.id, validatedRegistry);

    // Update indices
    this.addToIndices(validatedRegistry);

    return validatedRegistry;
  }

  /**
   * Get a registry by ID
   */
  getRegistry(id: string): Registry | undefined {
    return this.registries.get(id);
  }

  /**
   * Check if a registry exists
   */
  registryExists(id: string): boolean {
    return this.registries.has(id);
  }

  /**
   * Get registries by type
   */
  getRegistriesByType(type: string): Registry[] {
    const ids = this.typeIndex.get(type);
    if (!ids) return [];

    return Array.from(ids)
      .map(id => this.getRegistry(id))
      .filter(Boolean) as Registry[];
  }

  /**
   * Update a registry
   */
  updateRegistry(
    id: string,
    updates: {
      name?: string;
      description?: string;
      properties?: Record<string, any>;
      active?: boolean;
    }
  ): Registry | undefined {
    const registry = this.registries.get(id);

    if (!registry) {
      return undefined;
    }

    // Remove from indices before update
    this.removeFromIndices(registry);

    // Create updated registry
    const updatedRegistry: Registry = {
      ...registry,
      ...(updates.name ? { name: updates.name } : {}),
      ...(updates.description ? { description: updates.description } : {}),
      ...(updates.active !== undefined ? { active: updates.active } : {}),
      properties: {
        ...registry.properties,
        ...updates.properties
      },
      updatedAt: new Date()
    };

    // Validate with schema
    const validatedRegistry = RegistrySchema.parse(updatedRegistry);

    // Store updated registry
    this.registries.set(id, validatedRegistry);

    // Update indices
    this.addToIndices(validatedRegistry);

    return validatedRegistry;
  }

  /**
   * Update registry statistics
   */
  updateRegistryStats(
    id: string,
    stats: {
      entityCount?: number;
      relationCount?: number;
      contextCount?: number;
    }
  ): Registry | undefined {
    const registry = this.registries.get(id);

    if (!registry) {
      return undefined;
    }

    // Update registry stats
    const updatedRegistry = updateRegistryStats(registry, stats);

    // Validate with schema
    const validatedRegistry = RegistrySchema.parse(updatedRegistry);

    // Store updated registry
    this.registries.set(id, validatedRegistry);

    return validatedRegistry;
  }

  /**
   * Delete a registry
   */
  deleteRegistry(id: string): boolean {
    const registry = this.registries.get(id);

    if (!registry) {
      return false;
    }

    // Remove from indices
    this.removeFromIndices(registry);

    // Remove from storage
    return this.registries.delete(id);
  }

  /**
   * Mark a registry as inactive
   */
  deactivateRegistry(id: string): Registry | undefined {
    return this.updateRegistry(id, { active: false });
  }

  /**
   * Get all registries
   */
  getAllRegistries(): Registry[] {
    return Array.from(this.registries.values());
  }

  /**
   * Get all registry types
   */
  getAllRegistryTypes(): string[] {
    return Array.from(this.typeIndex.keys());
  }

  /**
   * Count registries
   */
  countRegistries(): number {
    return this.registries.size;
  }

  /**
   * Count registries by type
   */
  countRegistriesByType(type: string): number {
    return this.typeIndex.get(type)?.size || 0;
  }

  /**
   * Get active registries
   */
  getActiveRegistries(): Registry[] {
    return Array.from(this.registries.values())
      .filter(registry => registry.active);
  }

  /**
   * Associate entities, relations, and contexts with a registry
   *
   * Note: This is a placeholder for the actual implementation,
   * which would involve the EntityService, RelationService, and ContextService
   */
  associateElements(
    id: string,
    elements: {
      entityIds?: string[];
      relationIds?: string[];
      contextIds?: string[];
    }
  ): Registry | undefined {
    const registry = this.registries.get(id);

    if (!registry) {
      return undefined;
    }

    // In a real implementation, we would:
    // 1. Check that the entities, relations, and contexts exist
    // 2. Associate them with this registry
    // 3. Update the registry's statistics

    // For now, we'll just update the statistics
    const entityCount = registry.stats?.entityCount || 0;
    const relationCount = registry.stats?.relationCount || 0;
    const contextCount = registry.stats?.contextCount || 0;

    return this.updateRegistryStats(id, {
      entityCount: entityCount + (elements.entityIds?.length || 0),
      relationCount: relationCount + (elements.relationIds?.length || 0),
      contextCount: contextCount + (elements.contextIds?.length || 0)
    });
  }

  /**
   * Search registries
   */
  searchRegistries(query: string): Registry[] {
    if (!query) return this.getAllRegistries();

    const lowercaseQuery = query.toLowerCase();

    return Array.from(this.registries.values())
      .filter(registry =>
        registry.name.toLowerCase().includes(lowercaseQuery) ||
        (registry.description && registry.description.toLowerCase().includes(lowercaseQuery))
      );
  }
}

// Export singleton instance
export const registryService = RegistryService.getInstance();
