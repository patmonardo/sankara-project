import { FormEntity } from "@/form/entity/entity";
import { Sandarbha } from "@/form/context/context";

export type FormRelationId = string;
// Define a type for the verb listener callback
type VerbListenerCallback = (relation: FormRelation) => void;

export class FormRelation<T = any> {
  private static relations: Map<string, FormRelation> = new Map();
  private static verbListeners: VerbListenerCallback[] = [];

  public id: FormRelationId;
  public type: string; // e.g., 'relation', 'event', 'message'
  public source: FormEntity;
  public target?: FormEntity;
  public subtype?: string; // The specific "verb" name or relation type
  public content?: T;
  public metadata?: Record<string, any>;
  public timestamp?: number;

  /**
   * Create a new relation instance
   */
  constructor(config: {
    id?: string;
    type: string;
    source: FormEntity;
    target?: FormEntity;
    subtype?: string;
    content?: T;
    metadata?: Record<string, any>;
  }) {
    this.id =
      config.id ||
      `${config.type}:${Date.now()}:${Math.random().toString(36).substring(2, 9)}`; // Prefix ID with type
    this.type = config.type;
    this.source = config.source;
    this.target = config.target;
    this.subtype = config.subtype;
    this.content = config.content;
    this.metadata = config.metadata || { created: Date.now() };
    // Ensure timestamp aligns with metadata.created if available
    this.timestamp = typeof this.metadata.created === 'number' ? this.metadata.created : Date.now();
  }

  /**
   * Subscribe to notifications when new 'event' or 'message' relations (verbs) are created.
   * @param callback The function to call with the new verb relation.
   * @returns An object with an `unsubscribe` method.
   */
  static subscribeToVerbs(callback: VerbListenerCallback): { unsubscribe: () => void } {
    this.verbListeners.push(callback);
    return {
      unsubscribe: () => {
        this.verbListeners = this.verbListeners.filter(listener => listener !== callback);
      }
    };
  }

  /**
   * Notifies registered listeners about a newly created verb ('event' or 'message').
   * Simplified: Ignores potential errors in listeners.
   */
  private static notifyVerbListeners(relation: FormRelation): void {
    // Only notify for 'event' and 'message' types
    if (relation.type === 'event' || relation.type === 'message') {
      // console.debug(`Notifying ${this.verbListeners.length} listeners about verb: ${relation.subtype} (ID: ${relation.id})`);
      this.verbListeners.forEach(listener => listener(relation));
    }
  }

  /**
   * Create a persistent relation from configuration.
   * This does NOT notify verb listeners by default.
   */
  static createRelation(config: {
    sourceId: string;
    targetId?: string;
    type: string; // The persistent relation type (e.g., 'dependency', 'composition')
    content?: any;
    contextId?: string;
    subtype?: string; // Optional subtype for the persistent relation (defaults to type)
    metadata?: Record<string, any>;
  }): string {
    const sourceEntity = FormEntity.getEntity(config.sourceId);
    if (!sourceEntity) {
      console.error(`Source entity ${config.sourceId} not found for createRelation.`);
      throw new Error(`Source entity ${config.sourceId} not found`);
    }
    const targetEntity = config.targetId ? FormEntity.getEntity(config.targetId) : undefined;
    if (config.targetId && !targetEntity) {
       console.warn(`Target entity ${config.targetId} not found for createRelation.`);
    }

    const relation = new FormRelation({
        // id generated by constructor with 'relation:' prefix
        type: 'relation', // Explicitly set type to 'relation'
        source: sourceEntity,
        target: targetEntity,
        subtype: config.subtype || config.type, // Use subtype, fallback to type
        content: config.content,
        metadata: {
            ...(config.metadata || {}),
            created: Date.now(),
            contextId: config.contextId
        }
    });

    FormRelation.relations.set(relation.id, relation);

    if (config.contextId) {
        const context = Sandarbha.getSandarbha(config.contextId);
        context?.sambandhaPañjīkaraṇa(relation.id);
    }

    return relation.id;
  }

  /**
   * Get a relation by ID
   */
  static getRelation(id: string): FormRelation | undefined {
    return FormRelation.relations.get(id);
  }

  /**
   * Update a relation with new properties
   */
  static updateRelation(id: string, updates: Partial<FormRelation>): boolean {
    const relation = FormRelation.relations.get(id);
    if (!relation) return false;

    // Create updated relation object
    const updatedRelationData = {
      ...relation,
      ...updates,
      metadata: {
        ...(relation.metadata || {}),
        ...(updates.metadata || {}),
        updated: Date.now(),
      },
      timestamp: Date.now(), // Update timestamp on update
    };
    // Re-create instance to ensure consistency (optional, could just update map)
    const updatedRelation = new FormRelation(updatedRelationData);

    FormRelation.relations.set(id, updatedRelation);
    // Note: We are NOT notifying listeners on updates in this design.
    return true;
  }

  /**
   * Emit an event verb.
   * Notifies listeners after creation.
   */
  static emit(
    source: FormEntity,
    verbSubtype: string, // The specific verb name
    content: Record<string, any>,
    metadata?: Record<string, any>
  ): string {
    const event = new FormRelation({
        // id generated by constructor with 'event:' prefix
        type: "event",
        source: source,
        subtype: verbSubtype,
        content: content,
        metadata: metadata // Constructor handles created timestamp
    });

    this.relations.set(event.id, event);
    // --- Notify listeners about the new verb ---
    this.notifyVerbListeners(event);
    // --- End Notify ---
    return event.id;
  }

  /**
   * Send a message verb to a specific target.
   * Notifies listeners after creation.
   */
  static send(
    source: FormEntity,
    target: FormEntity,
    verbSubtype: string, // The specific verb name
    content: Record<string, any>,
    metadata?: Record<string, any>
  ): string {
     const message = new FormRelation({
        // id generated by constructor with 'message:' prefix
        type: "message",
        source: source,
        target: target,
        subtype: verbSubtype,
        content: content,
        metadata: metadata // Constructor handles created timestamp
    });

    this.relations.set(message.id, message);
    // --- Notify listeners about the new verb ---
    this.notifyVerbListeners(message);
    // --- End Notify ---
    return message.id;
  }

  /**
   * Broadcast a message verb to multiple targets.
   */
  static broadcast(
    source: FormEntity,
    targets: FormEntity[],
    verbSubtype: string,
    content: Record<string, any>,
    metadata?: Record<string, any>
  ): string[] {
    const messageIds: string[] = [];
    for (const target of targets) {
      const messageId = this.send(source, target, verbSubtype, content, metadata);
      messageIds.push(messageId);
    }
    return messageIds;
  }

  /**
   * Query relations (including verbs) by various criteria.
   */
  static query(filter: {
    type?: 'relation' | 'event' | 'message';
    sourceId?: string;
    targetId?: string;
    subtype?: string;
    since?: number;
  }): FormRelation[] {
    return Array.from(this.relations.values()).filter((relation) => {
      if (filter.type && relation.type !== filter.type) return false;
      if (filter.sourceId && relation.source.id !== filter.sourceId) return false;
      if (filter.targetId && relation.target?.id !== filter.targetId) return false;
      if (filter.subtype && relation.subtype !== filter.subtype) return false;
      if (filter.since && (!relation.timestamp || relation.timestamp <= filter.since)) return false;
      return true;
    });
  }

  /**
   * Remove a relation by ID
   */
  static remove(relationId: string): boolean {
    // Note: Not notifying listeners on removal in this design.
    return this.relations.delete(relationId);
  }
}