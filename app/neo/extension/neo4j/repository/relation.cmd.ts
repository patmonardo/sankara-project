import { Neo4jConnection } from "../connection";
import { RelationDefinitionRepository } from "./relation.def"; // Import Definition Repo
import { RelationShapeRepository } from "./relation"; // Import Shape Repo
import { FormRelationDefinition, FormRelation } from "@/form/schema/relation";
import * as dotenv from "dotenv";
import { v4 as uuidv4 } from "uuid";

// Load environment variables
dotenv.config();

/**
 * Test RelationRepository operations (Definition and Shape)
 */
async function testRelationRepositories() {
  // Renamed function
  console.log("Testing Relation Definition & Shape Repository operations...");
  let connection: Neo4jConnection | undefined; // Allow undefined for finally block

  try {
    // Create and initialize connection
    connection = new Neo4jConnection({
      uri: process.env.NEO4J_URI || "neo4j://localhost:7687",
      username: process.env.NEO4J_USERNAME || "neo4j",
      password: process.env.NEO4J_PASSWORD || "neo4j",
      useDefaultDriver: false, // Assuming you want to manage the driver instance
    });

    console.log("Initializing connection...");
    await connection.initialize();
    console.log("‚úÖ Connected to Neo4j");

    // Create repositories
    const relationDefRepo = new RelationDefinitionRepository(connection); // Instance for Definitions
    const relationShapeRepo = new RelationShapeRepository(connection); // Instance for Shapes

    // --- Test Data ---
    const definitionId = uuidv4();
    const sourceId = uuidv4();
    const targetId = uuidv4();
    // instanceId will be generated by createRelation

    // --- Cleanup before test (optional but recommended) ---
    console.log("\nüßπ CLEANING UP PREVIOUS TEST DATA (if any)...");
    const cleanupSession = connection.getSession({
      defaultAccessMode: "WRITE",
    });
    try {
      await cleanupSession.run(
        `MATCH (r:RelationDefinition {id: $definitionId}) DETACH DELETE r`,
        { definitionId }
      );
      await cleanupSession.run(
        `MATCH (s:Entity {id: $sourceId}) DETACH DELETE s`,
        { sourceId }
      );
      await cleanupSession.run(
        `MATCH (t:Entity {id: $targetId}) DETACH DELETE t`,
        { targetId }
      );
      // Also delete instances by definitionId if needed
      await cleanupSession.run(
        `MATCH ()-[r {definitionId: $definitionId}]-() DELETE r`,
        { definitionId }
      );
      console.log("‚úÖ Cleanup complete.");
    } catch (cleanupError) {
      console.warn("Cleanup failed (might be first run):", cleanupError);
    } finally {
      await cleanupSession.close();
    }

    // 1. DEFINITION OPERATIONS
    console.log("\n==== RELATION DEFINITION OPERATIONS ====");

    // 1.1. Create a relation definition
    console.log("\nüìù CREATING RELATION DEFINITION:");
    const relationDefinition: FormRelationDefinition = {
      id: definitionId,
      name: "Tests Relation",
      description: "A test relation definition",
      type: "TEST_RELATION",
      createdAt: Date.now(),
      // updatedAt will be set by saveRelationDefinition
      cardinality: "many-to-many",
      inverse: {
        type: "REFERENCED_BY",
        name: "Referenced By",
      },
      constraints: [
        // Add example constraints
        {
          id: "constraint1",
          name: "UniqueConstraint",
          type: "sourceType",
          value: "Person",
          message: "Source must be a Person",
        },
        {
          id: "constraint2",
          name: "UniqueConstraint",
          type: "targetType",
          value: "Document",
          message: "Target must be a Document",
        },
      ],
      tags: ["test", "example"],
      behaviors: [
        // Add example behavior
        {
          id: "behavior1",
          name: "LogAccess",
          event: "onRead",
          handler: 'function log(rel) { console.log("Accessed:", rel.id); }',
          active: true,
        },
      ],
    };

    console.log(
      "Definition to save:",
      JSON.stringify(relationDefinition, null, 2)
    );
    // Use relationDefRepo
    const savedDefinition = await relationDefRepo.saveRelationDefinition(
      relationDefinition
    );
    console.log("‚úÖ Saved definition:", savedDefinition.id);
    console.log(
      "Saved definition details:",
      JSON.stringify(savedDefinition, null, 2)
    );

    // 1.2. Get the definition by ID
    console.log("\nüîç GETTING RELATION DEFINITION:");
    // Use relationDefRepo
    const fetchedDefinition = await relationDefRepo.getRelationDefinitionById(
      definitionId
    );
    if (!fetchedDefinition) throw new Error("Failed to fetch definition");
    console.log(
      "Fetched definition:",
      JSON.stringify(fetchedDefinition, null, 2)
    );

    // 1.3 Find definition by type
    console.log("\nüîç FINDING RELATION DEFINITION BY TYPE:");
    // Use relationDefRepo
    const foundDefinitionsByType =
      await relationDefRepo.findRelationDefinitions({
        type: "TEST_RELATION",
        limit: 10,
      });
    console.log(
      `Found ${foundDefinitionsByType.length} definitions by type:`,
      JSON.stringify(foundDefinitionsByType, null, 2)
    );

    // 1.4 Find definition by tag
    console.log("\nüîç FINDING RELATION DEFINITION BY TAG:");
    // Use relationDefRepo
    const foundDefinitionsByTag = await relationDefRepo.findRelationDefinitions(
      {
        tag: "example",
        limit: 10,
      }
    );
    console.log(
      `Found ${foundDefinitionsByTag.length} definitions by tag:`,
      JSON.stringify(foundDefinitionsByTag, null, 2)
    );

    // 1.5 Update definition
    console.log("\nüîÑ UPDATING RELATION DEFINITION:");
    const updatedDef = await relationDefRepo.updateRelationDefinition(
      definitionId,
      {
        description: "Updated description",
        tags: ["test", "updated"], // Overwrites tags
        traversalCost: 5,
      }
    );
    if (!updatedDef) throw new Error("Failed to update definition");
    console.log("‚úÖ Updated definition:", JSON.stringify(updatedDef, null, 2));

    // 2. SHAPE (INSTANCE) OPERATIONS
    console.log("\n==== RELATION SHAPE (INSTANCE) OPERATIONS ====");

    // 2.1. Create test entities (Prerequisite for instance creation)
    console.log("\nüë§ CREATING TEST ENTITIES:");
    const entitySession = connection.getSession({ defaultAccessMode: "WRITE" });
    try {
      await entitySession.run(
        `
        MERGE (source:Entity:Person {id: $sourceId}) ON CREATE SET source.name = 'Test Person', source.type = 'Person'
        MERGE (target:Entity:Document {id: $targetId}) ON CREATE SET target.name = 'Test Document', target.type = 'Document'
      `,
        { sourceId, targetId }
      );
      console.log(
        "‚úÖ Created/Merged test entities with IDs:",
        sourceId,
        targetId
      );
    } finally {
      await entitySession.close();
    }

    // 2.2. Create a relation instance using createRelation
    console.log("\nüîó CREATING RELATION INSTANCE (using createRelation):");
    const instanceData = {
      definitionId: definitionId,
      sourceId: sourceId,
      targetId: targetId,
      properties: {
        // Add custom properties
        priority: 1,
        notes: "Initial connection",
      },
      contextId: uuidv4(),
      createdBy: "test-script",
    };
    console.log(
      "Instance data to create:",
      JSON.stringify(instanceData, null, 2)
    );
    // Use relationShapeRepo
    const createdInstance = await relationShapeRepo.createRelation(
      instanceData
    );
    const instanceId = createdInstance.id; // Get the generated ID
    console.log("‚úÖ Created instance:", instanceId);
    console.log(
      "Created instance details:",
      JSON.stringify(createdInstance, null, 2)
    );

    // 2.3. Get the instance by ID
    console.log("\nüîç GETTING RELATION INSTANCE:");
    // Use relationShapeRepo
    const fetchedInstance = await relationShapeRepo.getRelationById(instanceId);
    if (!fetchedInstance) throw new Error("Failed to fetch instance");
    console.log("Fetched instance:", JSON.stringify(fetchedInstance, null, 2));

    // 2.4. Find instances by definition ID
    console.log("\nüîç FINDING INSTANCES BY DEFINITION ID:");
    // Use relationShapeRepo
    const foundInstancesByDef = await relationShapeRepo.findRelations({
      definitionId: definitionId,
      limit: 10,
    });
    console.log(
      `Found ${foundInstancesByDef.length} instances by definition ID:`,
      JSON.stringify(foundInstancesByDef, null, 2)
    );

    // 2.5. Find instances by source ID
    console.log("\nüîç FINDING INSTANCES BY SOURCE ID:");
    // Use relationShapeRepo
    const foundInstancesBySource = await relationShapeRepo.findRelations({
      sourceId: sourceId,
      limit: 10,
    });
    console.log(
      `Found ${foundInstancesBySource.length} instances by source ID:`,
      JSON.stringify(foundInstancesBySource, null, 2)
    );

    // 2.6. Get entity relations (outgoing from source)
    console.log("\nüîç GETTING ENTITY RELATIONS (outgoing from source):");
    // Use relationShapeRepo
    const sourceRelations = await relationShapeRepo.getEntityRelations(
      sourceId,
      { direction: "outgoing" }
    );
    console.log(
      `Found ${sourceRelations.length} outgoing relations for source:`,
      JSON.stringify(sourceRelations, null, 2)
    );

    // 2.7. Find connected entities (outgoing from source)
    console.log("\nüîç FINDING CONNECTED ENTITIES (outgoing from source):");
    // Use relationShapeRepo
    const connectedEntities = await relationShapeRepo.findConnectedEntities({
      startEntityId: sourceId,
      direction: "outgoing",
      limit: 5,
    });
    console.log(
      `Found ${connectedEntities.length} connected entities:`,
      JSON.stringify(connectedEntities, null, 2)
    );

    // 2.8. Update relation instance
    console.log("\nüîÑ UPDATING RELATION INSTANCE:");
    // Use relationShapeRepo
    const updatedInstance = await relationShapeRepo.updateRelation(instanceId, {
      weight: 0.8,
      active: false,
      properties: {
        priority: 2,
        status: "reviewed",
      },
    });
    if (!updatedInstance) throw new Error("Failed to update instance");
    console.log(
      "‚úÖ Updated instance:",
      JSON.stringify(updatedInstance, null, 2)
    );

    // // 2.9 Get relation stats
    console.log("\nüìä GETTING RELATION STATS:");
    // Use relationShapeRepo
    const stats = await relationShapeRepo.getRelationStats();
    console.log("Relation stats:", JSON.stringify(stats, null, 2));

    // 3. DELETION OPERATIONS
    console.log("\n==== DELETION OPERATIONS ====");

    // 3.1. Delete the instance
    console.log("\nüóëÔ∏è DELETING RELATION INSTANCE:");
    // Use relationShapeRepo
    const instanceDeleted = await relationShapeRepo.deleteRelation(instanceId);
    console.log(
      instanceDeleted
        ? "‚úÖ Instance deleted successfully."
        : "‚ùå Instance deletion failed."
    );

    // 3.2. Delete the definition (should fail if instances exist and force=false)
    // Try deleting without force first (should fail if instance deletion failed above)
    try {
      console.log("\nüóëÔ∏è TRYING TO DELETE RELATION DEFINITION (force=false):");
      await relationDefRepo.deleteRelationDefinition(definitionId, false);
      console.log("‚ùå Definition deleted without force (unexpected).");
    } catch (error: any) {
      console.log(
        "‚úÖ Correctly failed to delete definition without force:",
        error.message
      );
    }

    // Now delete with force=true
    console.log("\nüóëÔ∏è DELETING RELATION DEFINITION (force=true):");
    // Use relationDefRepo
    const definitionDeleted = await relationDefRepo.deleteRelationDefinition(
      definitionId,
      true
    ); // Use force=true
    console.log(
      definitionDeleted
        ? "‚úÖ Definition deleted successfully with force."
        : "‚ùå Definition deletion failed with force."
    );

    // 3.3 Delete test entities
    console.log("\nüóëÔ∏è DELETING TEST ENTITIES:");
    const deleteEntitySession = connection.getSession({
      defaultAccessMode: "WRITE",
    });
    try {
      await deleteEntitySession.run(
        `MATCH (s:Entity {id: $sourceId}) DETACH DELETE s`,
        { sourceId }
      );
      await deleteEntitySession.run(
        `MATCH (t:Entity {id: $targetId}) DETACH DELETE t`,
        { targetId }
      );
      console.log("‚úÖ Deleted test entities.");
    } finally {
      await deleteEntitySession.close();
    }

    console.log("\nüéâ All Relation Repository tests completed successfully!");
  } catch (error) {
    console.error("\n‚ùå ERROR DURING RELATION REPOSITORY TEST:", error);
  } finally {
    if (connection) {
      console.log("\nClosing connection...");
      await connection.close();
      console.log("‚úÖ Connection closed.");
    }
  }
}

// Execute the test function
testRelationRepositories();
